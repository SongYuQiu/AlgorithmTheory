# AlgorithmTheory 《算法理论》presentation练习

### problem1-预测学生排名
- 用一个标记数组Bool[6]标记每个老师的说法，对的就是1，不对就是0
- 满足的条件就是，每个老师的标记值和为1；四个学生的排名互不一样

### problem2-凸多边形找坐标值最大点
- 对于横坐标x，可以用二分法，因为x先增大后减小；
- 对于纵坐标y，不可以使用二分法，先找到x最大的点，从该点开始往后找到y极大点，再与x最大的点的y进行比较

### problem3-合并排序
- 两个数组的一次比较大小，用index1和index2分别标记已经排到两个数组的什么位置。
- 可以从左到右，可以从右到左。
- 如果要从左到右开始的话，就要另外再定义一个数组进行存储，否则nums1的数值会丢失；
- 从右到左开始的话，可以直接将数字存在nums1的里面就可以了。

### problem4-找出假币
- 需要注意的是，找假币是找它的位置，不单单是找它的重量，所以排序之后对比首尾是不可取的。
- 减治法，将规模缩小，有些类似二分法，但又不完全一样。
- 有个找规律的想法在里面，时间复杂度O(log2 n)

### problem5-计数
- 遍历：一个个判断是否等于n，然后count计数
- 本质上在输入数组的时候直接定义一个计数数组的原理其实也是遍历，时间复杂度都是O(n)
- 二分法找数字出现的位置和结束的位置，两个位置序号相减，时间复杂度是O(log2 n)

### problem6-找出两个数和为特定值

- 时间复杂度O(n)

- 若只是简单的遍历，时间复杂度为O(n^2)，这样没有充分利用已经排好序的条件，不可取；

- 定义两个指针p和q，分别指向头和尾，比较这两数之和与给定数的大小关系，直到找到符合条件的一对数字，若p>q，则说明没有找到。

### problem7-DFS找指定路径和路径

### problem8-构建平衡二叉树

### problem9-跳台阶问题

- 递归求解，用F(n)表示第n个台阶的跳法总数

- 第一个台阶：一种可能性，F(1)=1

- 第二个台阶：两种可能性，F(2)=2

- 对于第n个台阶而言，它有可能是第n-1个台阶跳一步来的，也可能是第n-2个台阶跳两步来的，所以F(n)=F(n-1)+ F(n-2)

- 时间复杂度O(2^n)

- 还可以用动态规划、斐波拉契数列（迭代）做

### problem10-合并排序

- 跟problem3重复

### problem11-找第一个大于/小于的数

- 暴力搜索

- 对于数组有序无序都可以，时间复杂度O(n)，空间复杂度O(1)

### problem12-N皇后



### problem13-最大自序列和

- 动态规划

- 令dp[i]表示一定以num[i]为结尾的子序列的最大和的状态

- dp[i] = max{ num[i], dp[i-1]+num[i] }

- dp[0]=num[0]

- start和end来标记当前最大子序列和的起始位置



### problem15-活动安排

- 区间贪心

- 将活动按照开始时间按照（开始时间的数值大小）从大到小排序

- 总是选择左端点最大的区间



### problem21-最少的lecture安排活动

- 根据开始和结束时间进行活动

- 用一个记忆数组num来记录需要最多的lecture的数量

- 一个活动的时间是[a,b)，那么设置[a,b)区间的num[i]++

- 找出num[i]的最大值即为需要的最少的lecture数量

- 本质上就是区间最多重叠数的计算



### problem27-背包问题（贪心）

- 既然是用贪心算法来解决背包问题，那么这里的物品是可以只取部分的，并不是一个完整的不可分割的整体；

- 按照物品的含金量从高到低排序，依次存入背包，直至刚好装满。

### problem30-0/1背包问题（动态规划）

- 动态规划解决，dp[i][v]表示到第i个物品恰好放入v容量背包的价值最大的状态

- 状态转移方程：

​	- dp[i] [v]=max{ dp[i-1] [v] , dp[i-1] [v-w[i]]+c[i] }

​	- 0≤i≤n , w[i]≤v≤V

​	- 边界 dp[0] [v]=0

​	- 遍历dp[n] [v]找到最大值

- 状态转移方程优化：二维变一维

​	- dp[v]表示恰好放入容量为v的背包的物品的最大价值

​	- dp[v]=max{ dp[v], dp[v-w[i]]+c[i] }

​	- 注意v是逆序

​	- 初始边界：dp[v]=0 (0≤v≤V)

### problem31-最小的K个数



### problem34-在给定字符串序列中找到指定字符串

- 暴力搜索
- 字符串序列是按字母序的，所以可以考虑二分法



### problem36-数塔问题

- 动态规划

### problem41-lecture活动安排（真正的贪心）

- 前面problem15的做法并不是真正的贪心

- 贪心的做法应该是将所有活动的开始时间和结束时间分别各自按照从小到大排序

- 用i和j分别标记开始时间数组和结束时间数组

- start[i]<end[j]的时候说明上一个活动还没结束，就有新的活动开始了，这时候会场数就需要加1，否则就是j++，说明有会场空出来了，更新最晚时间。

### problem42-0/1背包问题（动态规划）

- 跟problem30重复

### problem46-在给定字符串序列中找到指定字符串

- 跟problem34重复

### problem51-0/1背包问题（回溯）

- 回溯法解决

- cw表示当前背包重量

- cv表示当前背包价值

- bestv表示当前最优解

- 当index≥n时，到达叶子节点，判断是否比最优的更优

- 当cw+w[index]>c时，超过背包容量，不用判断左子树，剪枝

- 当cv+剩余物品总价值≤bestv时，不比当前更优，不用判断右子树，剪枝

- 这里没有写输出选用了哪些物品

### problem62-最小平均完成时间

- 短作业优先原则

- 按照时长从小到大排序进行计算

### problem65-0/1背包问题（回溯 剪枝优化）

- 按照物品的单位价值的高低进行排序

- 剪枝条件1:当超过容量时，直接不用考虑进入左子树； 剪枝条件2:当前价值加上剩余价值的和小于当前最优价值时，不用考虑进入右子树

- 剪枝条件2更优化的做法：

- （物品事前已经按照单位价值的高低排好序了）

- 用当前背包的总价值 加上后面物品的价值（按单位价值由高到低）

- 同时要满足不超过背包的总容量

- 当循环结束后，若还有物品没有放入背包，那么就加上下一个物品的单位价值*剩余的背包容量 因为虽然无法再继续放下一个物品，但是不代表不能选后面的

- 证明加上剩余价值的总和还是有可能大于bestv的同时，相比于基础的回溯剪去了更多的枝

### problem67-最大自序列和

- 跟problem13重复

### problem71-活动安排（重复）

- problem15重复

### problem72-0/1背包问题（分支限界法）



### problem79-最小的K个数

- 跟problem31重复
